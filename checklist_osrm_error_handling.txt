Checklist: Обработка ошибок OSRM на фронтенде

**Цель:** Предотвратить пропадание информации о маршруте и дать возможность повторить запрос к OSRM при ошибках таймаута или других ошибках построения маршрута на карте.

**Файлы для модификации:**
*   `frontend/static/js/step3_results.js` (основная логика Шага 3, включая отображение таблицы и карты)
*   `frontend/static/js/app.js` (функции `showMap`, `clearMapMarkers` и, возможно, обработка ошибок)
*   `frontend/templates/index.html` (возможно, для добавления нового элемента, например, кнопки "Повторить")
*   `frontend/static/css/styles.css` (или `step3_results.css`) (для стилизации кнопки/сообщения об ошибке)

**Шаги:**

1.  **[app.js / step3_results.js] Найти место вызова `Leaflet Routing Machine`:**
    *   Локализовать код, где создается `L.Routing.control` или вызывается метод `.setWaypoints()` для отрисовки маршрута. Вероятно, это внутри `showMap` в `app.js` или в функции, вызывающей `showMap` из `step3_results.js`.

2.  **[app.js / step3_results.js] Добавить обработчик события ошибки:**
    *   У экземпляра `L.Routing.control` найти способ подписаться на событие ошибки (например, `'routingerror'`).
    *   В колбэке обработчика ошибки:
        *   Получить детали ошибки (если доступны), особенно проверить, связана ли она с таймаутом OSRM.
        *   Вывести в консоль понятное сообщение об ошибке для отладки.

3.  **[app.js / step3_results.js] Предотвратить JavaScript `TypeError` (`reading 'removeLayer'`):**
    *   В обработчике ошибки (`'routingerror'`) или перед ним, убедиться, что последующие операции (особенно очистка слоев, например, `_clearLines` или `map.removeLayer`) не будут вызваны для `null` объектов.
    *   Возможно, потребуется вручную вызвать `routingControl.setWaypoints(null)` или `map.removeControl(routingControl)` для корректной очистки состояния, *прежде чем* произойдет внутренняя ошибка библиотеки.
    *   Использовать `try...catch` вокруг вызова `showMap` или внутри `showMap` вокруг операций с `routingControl`, чтобы перехватить любые непредвиденные ошибки и не дать упасть всему скрипту.

4.  **[app.js / step3_results.js] Сохранить отображение данных маршрута:**
    *   Убедиться, что даже при ошибке OSRM (`'routingerror'`) или `TypeError`:
        *   Функция `updateDisplay` (в `step3_results.js`) все равно вызывается/завершается корректно.
        *   Блоки с `distance-value`, `duration-value`, `total-route-time-value` и таблица адресов (`geocoder-table`) остаются видимыми и отображают данные, полученные с бэкенда для текущего `currentRouteData`.

5.  **[index.html / CSS / JS] Добавить механизм повторного запроса:**
    *   В обработчике ошибки OSRM (`'routingerror'`):
        *   Показать пользователю сообщение об ошибке (например, "Не удалось построить маршрут на карте. Попробовать снова?").
        *   Показать кнопку "Перестроить маршрут на карте" (либо добавить ее статически в `index.html` и делать видимой/скрытой, либо создавать динамически в JS).
    *   При нажатии на эту кнопку:
        *   Скрыть сообщение об ошибке и кнопку.
        *   Получить текущие точки (`currentRouteData.route_points`).
        *   Повторно вызвать `showMap(currentRouteData.route_points)` (или ту часть `showMap`, которая отвечает за `routingControl.setWaypoints`).
        *   (Опционально) Показать временный индикатор загрузки на кнопке или карте.

6.  **[Тестирование] Проверить различные сценарии:**
    *   Нормальная работа: маршрут строится, данные отображаются.
    *   Ошибка OSRM (таймаут): линия маршрута не строится, *но* данные (расстояние, время, таблица) остаются, появляется сообщение об ошибке и кнопка "Повторить".
    *   Нажатие "Повторить": выполняется повторная попытка построить маршрут.
    *   Переключение между маршрутами после ошибки OSRM на одном из них. 